<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
      	margin: 0;
      }

      canvas {
      	position: fixed;
      	top: 0;
      	left: 0;
      	right: 0;
      	bottom: 0;
      }
    </style>
    <title>Black Hole test</title>
  </head>

  <body>
    <script src="./eruda.js"></script>
    <script src="./loadEruda.js"></script>
    <script src="./libraries/stats.js"></script>
    <script>
      const bounce = false;

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      document.body.appendChild(canvas);


      const stats = new Stats();
      document.body.appendChild(stats.dom);
      stats.dom.id = "stats";

      /**
       * @type {Body[]}
       */
      const bodies = [];

      const gravitationalConstant = 1;

      class Body {
        constructor({
          x = 0,
          y = 0,
          pinned = false,
          color = "black",
          mass = 1,
          radius = null,
          vx = 0,
          vy = 0,
        }) {
          this.x = x;
          this.y = y;
          this.pinned = pinned;
          this.color = color;
          this.mass = mass;
          this._radius = radius;

          this.vx = vx;
          this.vy = vy;
        }

        get radius() {
          return this._radius || Math.sqrt(this.mass) / 1.5;
        }
        set radius(radius) {
          this._radius = radius;
          return radius;
        }

        update() {
          if (this.pinned) return;
          bodies.forEach((body) => {
            if (body === this) return;
            let distance = Math.sqrt((this.x - body.x) ** 2 + (this.y - body.y) ** 2);
            if (distance <= this.radius + body.radius) {
              this.mass += body.mass;
              const idx = body.pinned ? bodies.indexOf(this) : bodies.indexOf(body);
              bodies.splice(idx, 1);
            } else {
              const force =
                (gravitationalConstant * this.mass * body.mass) / distance ** 2;
              this.vx += (force * (body.x - this.x)) / distance;
              this.vy += (force * (body.y - this.y)) / distance;
            }
          });

          this.x += this.vx;
          this.y += this.vy;

          if (bounce) {
            if (
              this.x - this.radius / 2 <= 0 ||
              this.x + this.radius / 2 >= canvas.width
            ) {
              this.vx *= -1;
            }

            if (
              this.y - this.radius / 2 <= 0 ||
              this.y + this.radius / 2 >= canvas.height
            ) {
              this.vy *= -1;
            }
          }
        }

        render() {
          ctx.beginPath();
          ctx.fillStyle = this.color;

          ctx.arc(
            this.x,
            this.y,
            this.radius || Math.sqrt(this.mass) * 3,
            0,
            Math.PI * 2
          );

          ctx.fill();
        }
      }

      const render = () => {
        stats.begin();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (addingBody) {
          ctx.beginPath();
          ctx.strokeStyle = "red";
          ctx.lineWidth = 5;

          ctx.moveTo(newBodyPos.x, newBodyPos.y);
          ctx.lineTo(velPos.x, velPos.y);

          ctx.stroke();
        }

        bodies.forEach((body) => body.update());
        bodies.forEach((body) => body.render());

        stats.end();

        requestAnimationFrame(render);
      };

      // const blackHole = new Body({
      //   x: window.innerWidth / 2,
      //   y: window.innerHeight / 2,
      //   pinned: true,
      //   color: "black",
      //   mass: 500,
      //   // radius: 5,
      // });

      // bodies.push(blackHole);

      // blackHoleFolder.add(blackHole, "mass", 1, 1000);
      // blackHoleFolder.add(blackHole, "radius", 1, 400);
      // blackHoleFolder.open();

      const generateParticles = ({
        num = 1000,
        center = { x: window.innerWidth / 2, y: window.innerHeight / 2 },
        minDistance = 0,
        maxDistance = Math.min(window.innerHeight, window.innerWidth) / 2,
        minMass = .2,
        maxMass = .3,
        minVel = 2,
        maxVel = 3,
      } = {}) => {
        for (let i = 0; i < num; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * (maxDistance - minDistance) + minDistance;
          const velocity = Math.random() * (maxVel - minVel) + minVel;
          bodies.push(
            new Body({
              x: Math.cos(angle) * distance + center.x,
              y: Math.sin(angle) * distance + center.y,
              color: "black",
              mass: Math.random() * (maxMass - minMass) + minMass,
              vx: Math.cos(angle + Math.PI / 2) * velocity,
              vy: Math.sin(angle + Math.PI / 2) * velocity,
            })
          );
        }
      };

      generateParticles({});

      let addingBody = false;

      let newBodyPos = { x: 0, y: 0 };
      let velPos = { x: 0, y: 0 };

      canvas.addEventListener("mousedown", ({ clientX, clientY }) => {
        addingBody = true;

        newBodyPos = { x: clientX, y: clientY };
        velPos = { x: clientX, y: clientY };
      });

      window.addEventListener("mousemove", ({ clientX, clientY }) => {
        if (addingBody) {
          velPos = { x: clientX, y: clientY };
        }
      });

      window.addEventListener("mouseup", ({ clientX, clientY }) => {
        if (addingBody) {
          velPos = { x: clientX, y: clientY };

          addingBody = false;

          bodies.push(
            new Body({
              x: newBodyPos.x,
              y: newBodyPos.y,
              color: "black", //'#' + Math.floor(Math.random()*16777215).toString(16),
              mass: 6,
              vx: (velPos.x - newBodyPos.x) / 100,
              vy: (velPos.y - newBodyPos.y) / 100,
            })
          );
        }
      });

      requestAnimationFrame(render);
    </script>
  </body>
</html>
